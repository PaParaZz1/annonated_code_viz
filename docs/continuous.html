<!DOCTYPE html>
<html><head><meta charset="utf-8"></meta><title>Annonated Algorithm Visualization</title><link rel="stylesheet" href="pylit.css?v=1"></link><link rel="stylesheet" href="solarized.css"></link><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.css" integrity="sha384-Juol1FqnotbkyZUT5Z7gUPjQ9gzlwCENvUZTpQBAPxtusdwFLRy382PSDx5UUJ4/" crossorigin="anonymous"></link><script src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.js" integrity="sha384-97gW6UIJxnlKemYavrqDHSX3SiygeOwIZhwyOKRfSaf0JWKRVj9hLASHgFTzT+0O" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);" defer="True"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.61.0/lib/codemirror.min.css"></link><script src="https://cdn.jsdelivr.net/npm/codemirror@5.61.0/lib/codemirror.min.js"></script><script src="https://cdn.jsdelivr.net/npm/codemirror@5.61.0/mode/python/python.min.js"></script></head><body><div class="section" id="section-0"><div class="docs doc-strings"><p><p><a href="index.html"><b>HOME<br></b></a>PyTorch tutorial of <span style="color:#00cbf694;font-family:Monaco,IBMPlexMono;">Proximal Policy Optimization (PPO)</span>  algorithm for continuous action.<br><a href="https://arxiv.org/pdf/1707.06347.pdf">Related Link</a><br><br>PPO is one of the most popular policy gradient methods for deep reinforcement learning. It combines the classic Actor-Critic paradigm and the trust region policy optimization method into a simple yet effect algorithm design. Compared to some traditional RL algorithms like REINFORCE and A2C, PPO can deploy more stable and efficient policy optimization by using clipped surrogate objective mentioned below:<br>$$J(\theta) = \min(\frac{\pi_{\theta}(a_{t}|s_{t})}{\pi_{\theta_k}(a_{t}|s_{t})}A^{\theta_k}(s_{t},a_{t}),\text{clip}(\frac{\pi_{\theta}(a_{t}|s_{t})}{\pi_{\theta_k}(a_{t}|s_{t})}, 1-\epsilon,1+\epsilon)A^{\theta_k}(s_{t},a_{t}))$$<br>The final objective is a lower bound (i.e., a pessimistic bound) on the unclipped objective, which only ignore the change in probability ratio when it would make the objective improve, and we include it when it makes the objective worse.<br>Detailed notation definition can be found in <a href="https://github.com/opendilab/PPOxFamily/blob/main/chapter1_overview/chapter1_notation.pdf">Related Link</a>.<br><br>Continuous action space, one of the most commonly used action spaces, is often used in practical decision applications such as robot manipulation and drone control. It contains serveral controllable continuous actions and RL agent needs to output proper and accuracy values every execution. Continuous action space is often directly predicted or modelled by gaussian distribution (regression problem).<br><br>This tutorial is mainly composed of the following three parts, you can learn from these demo codes step by step or using them as code segment in your own program:<br>  - Policy Network Architecture<br>  - Sample Action Function<br>  - Main (Test) Function<br>More visulization results about PPO in continuous action space can be found in <a href="https://github.com/opendilab/PPOxFamily/issues/4">Related Link</a>.</p></p><a href="https://github.com/opendilab/PPOxFamily" target="_blank"><img alt="GitHub" style="max-width:100%;" src="https://img.shields.io/github/stars/opendilab/PPOxFamily?style=social"></img></a>  <a href="https://space.bilibili.com/1112854351?spm_id_from=333.337.0.0" target="_blank"><img alt="bilibili" style="max-width:100%;" src="https://img.shields.io/badge/bilibili-video%20course-blue"></img></a>  <a href="https://twitter.com/OpenDILab" rel="nofollow" target="_blank"><img alt="twitter" style="max-width:100%;" src="https://img.shields.io/twitter/follow/opendilab?style=social"></img></a><br><a href="https://github.com/opendilab/PPOxFamily/tree/main/chapter2_action/continuous_tutorial.py" target="_blank">View code on GitHub</a></div></div><div class="section" id="section-1"><div class="docs doc-strings"><p>        <b>Overview</b><br>            The definition of continuous action policy network used in PPO, which is mainly composed of three parts: encoder, mu and log_sigma.</p></div><div class="code"><pre><code id="code_1" name="py_code">from typing import Dict
import torch
import torch.nn as nn
from torch.distributions import Normal, Independent


class ContinuousPolicyNetwork(nn.Module):
    def __init__(self, obs_shape: int, action_shape: int) -> None:</code></pre></div></div><div class="section" id="section-3"><div class="docs doc-strings"><p>        PyTorch necessary requirements for extending <span style="color:#00cbf694;font-family:Monaco,IBMPlexMono;">nn.Module</span> . Our network should also subclass this class.</p></div><div class="code"><pre><code id="code_3" name="py_code">        super(ContinuousPolicyNetwork, self).__init__()</code></pre></div></div><div class="section" id="section-4"><div class="docs doc-strings"><p>        Define encoder module, which maps raw state into embedding vector.<br>        It could be different for various state, such as Convolution Neural Network (CNN) for image state and Multilayer perceptron (MLP) for vector state, respectively.<br>        Here we use two-layer MLP for vector state.<br>        $$ y = max(W_2 max(W_1x+b_1, 0) + b_2, 0)$$</p></div><div class="code"><pre><code id="code_4" name="py_code">        self.encoder = nn.Sequential(
            nn.Linear(obs_shape, 16),
            nn.ReLU(),
            nn.Linear(16, 32),
            nn.ReLU(),
        )</code></pre></div></div><div class="section" id="section-5"><div class="docs doc-strings"><p>        Define mu module, which is a FC and outputs the argument mu for gaussian distribution.<br>        $$ \mu = Wx + b $$</p></div><div class="code"><pre><code id="code_5" name="py_code">        self.mu = nn.Linear(32, action_shape)</code></pre></div></div><div class="section" id="section-6"><div class="docs doc-strings"><p>        Define log_sigma module, which is a learnable parameter but independent to state.<br>        Here we set it as log_sigma for the convenience of optimization and usage. You can also adjust its initial value for your demands.<br>        $$\sigma = e^w$$</p></div><div class="code"><pre><code id="code_6" name="py_code">        self.log_sigma = nn.Parameter(torch.zeros(1, action_shape))
</code></pre></div></div><div class="section" id="section-7"><div class="docs doc-strings"><p>        <b>Overview</b><br>            The computation graph of continuous action policy network used in PPO.<br>            <span style="color:#00cbf694;font-family:Monaco,IBMPlexMono;">x -> encoder -> mu -> \mu</span> .<br>            <span style="color:#00cbf694;font-family:Monaco,IBMPlexMono;">log_sigma -> exp -> sigma</span> .</p></div><div class="code"><pre><code id="code_7" name="py_code">    def forward(self, x: torch.Tensor) -> Dict[str, torch.Tensor]:</code></pre></div></div><div class="section" id="section-9"><div class="docs doc-strings"><p>        Transform original state into embedding vector, i.e. $$(B, *) -> (B, N)$$</p></div><div class="code"><pre><code id="code_9" name="py_code">        x = self.encoder(x)</code></pre></div></div><div class="section" id="section-10"><div class="docs doc-strings"><p>        Output the argument mu depending on the embedding vector, i.e. $$(B, N) -> (B, A)$$</p></div><div class="code"><pre><code id="code_10" name="py_code">        mu = self.mu(x)</code></pre></div></div><div class="section" id="section-11"><div class="docs doc-strings"><p>        Utilize broadcast mechanism to make the same shape between log_sigma and mu.<br>        <span style="color:#00cbf694;font-family:Monaco,IBMPlexMono;">zeros_like</span> operation doesn't pass gradient.<br>        <a href="https://pytorch.org/tutorials/beginner/introyt/tensors_deeper_tutorial.html#in-brief-tensor-broadcasting">Related Link</a></p></div><div class="code"><pre><code id="code_11" name="py_code">        log_sigma = self.log_sigma + torch.zeros_like(mu)</code></pre></div></div><div class="section" id="section-12"><div class="docs doc-strings"><p>        Utilize exponential operation to produce the actual sigma.<br>        $$\sigma = e^w$$</p></div><div class="code"><pre><code id="code_12" name="py_code">        sigma = torch.exp(log_sigma)
        return {'mu': mu, 'sigma': sigma}

</code></pre></div></div><div class="section" id="section-13"><div class="docs doc-strings"><p>    <b>Overview</b><br>        The function of sampling continuous action, input is a dict with two keys <span style="color:#00cbf694;font-family:Monaco,IBMPlexMono;">mu</span> and <span style="color:#00cbf694;font-family:Monaco,IBMPlexMono;">sigma</span> ,<br>        both of them has shape = (B, action_shape), output shape = (B, action_shape).<br>        In this example, the distributions shapes are:<br>        batch_shape = (B, ), event_shape = (action_shape, ), sample_shape = ().</p></div><div class="code"><pre><code id="code_13" name="py_code">def sample_continuous_action(logit: Dict[str, torch.Tensor]) -> torch.Tensor:</code></pre></div></div><div class="section" id="section-15"><div class="docs doc-strings"><p>    Construct gaussian distribution, i.e.<br>    $$X \sim \mathcal{N}(\mu,\,\sigma^{2})$$<br>    Its probability density function is: $$f(x) = \frac{1}{\sigma\sqrt{2\pi}} \exp\left( -\frac{1}{2}\left(\frac{x-\mu}{\sigma}\right)^{\!2}\,\right)$$<br>    <a href="https://en.wikipedia.org/wiki/Normal_distribution">Related Link</a></p></div><div class="code"><pre><code id="code_15" name="py_code">    dist = Normal(logit['mu'], logit['sigma'])</code></pre></div></div><div class="section" id="section-16"><div class="docs doc-strings"><p>    Reinterpret <span style="color:#00cbf694;font-family:Monaco,IBMPlexMono;">action_shape</span> gaussian distribution into a multivariate gaussian distribution with diagonal convariance matrix.<br>    Ensure each event is independent with each other.<br>    <a href="https://pytorch.org/docs/stable/distributions.html#independent">Related Link</a></p></div><div class="code"><pre><code id="code_16" name="py_code">    dist = Independent(dist, 1)</code></pre></div></div><div class="section" id="section-17"><div class="docs doc-strings"><p>    Sample one action of the shape <span style="color:#00cbf694;font-family:Monaco,IBMPlexMono;">action_shape</span> per sample (state input) and return it.</p></div><div class="code"><pre><code id="code_17" name="py_code">    return dist.sample()

</code></pre></div></div><div class="section" id="section-18"><div class="docs doc-strings"><p>    <b>Overview</b><br>        The function of testing sampling continuous action. Construct a standard continuous action<br>        policy and sample a group of action.</p></div><div class="code"><pre><code id="code_18" name="py_code">def test_sample_continuous_action():</code></pre></div></div><div class="section" id="section-20"><div class="docs doc-strings"><p>    Set batch_size = 4, obs_shape = 10, action_shape = 6.<br>    <span style="color:#00cbf694;font-family:Monaco,IBMPlexMono;">action_shape</span> is different from discrete and continuous action. The former is the possible<br>    choice of a discrete action while the latter is the dimension of continuous action.</p></div><div class="code"><pre><code id="code_20" name="py_code">    B, obs_shape, action_shape = 4, 10, 6</code></pre></div></div><div class="section" id="section-21"><div class="docs doc-strings"><p>    Generate state data from uniform distribution in [0, 1].</p></div><div class="code"><pre><code id="code_21" name="py_code">    state = torch.rand(B, obs_shape)</code></pre></div></div><div class="section" id="section-22"><div class="docs doc-strings"><p>    Define continuous action network (which is similar to reparameterization) with encoder, mu and log_sigma.</p></div><div class="code"><pre><code id="code_22" name="py_code">    policy_network = ContinuousPolicyNetwork(obs_shape, action_shape)</code></pre></div></div><div class="section" id="section-23"><div class="docs doc-strings"><p>    Policy network forward procedure, input state and output dict-type logit.<br>    $$ \mu, \sigma = \pi(a|s)$$</p></div><div class="code"><pre><code id="code_23" name="py_code">    logit = policy_network(state)
    assert isinstance(logit, dict)
    assert logit['mu'].shape == (B, action_shape)
    assert logit['sigma'].shape == (B, action_shape)</code></pre></div></div><div class="section" id="section-24"><div class="docs doc-strings"><p>    Sample action accoding to corresponding logit (i.e., mu and sigma).</p></div><div class="code"><pre><code id="code_24" name="py_code">    action = sample_continuous_action(logit)
    assert action.shape == (B, action_shape)

</code></pre></div></div><div class="section" id="section-24"><div class="docs doc-strings"><p><i>If you have any questions or advices about this documation, you can raise issues in GitHub (https://github.com/opendilab/PPOxFamily) or email us (opendilab@pjlab.org.cn).</i></p></div></div></body><script type="text/javascript">
window.onload = function(){
    var codeElement = document.getElementsByName('py_code');
    var lineCount = 1;
    for (var i = 0; i < codeElement.length; i++) {
        var code = codeElement[i].innerText;
        if (code.length <= 1) {
            continue;
        }

        codeElement[i].innerHTML = "";

        var codeMirror = CodeMirror(
          codeElement[i],
          {
            value: code,
            mode: "python",
            theme: "solarized dark",
            lineNumbers: true,
            firstLineNumber: lineCount,
            readOnly: false,
            lineWrapping: true,
          }
        );
        var noNewLineCode = code.replace(/[\r\n]/g, "");
        lineCount += code.length - noNewLineCode.length + 1;
    }
};
</script></html>